# ì •ë ¬ ì •ë¦¬
1. Bubble
2. Selection
3. Insertion
4. Heap
5. Merge
6. Quick
7. Count
8. Radix
9. Topological
---
- ì‹œê°„ ê³„ì‚° : ë¹„êµ / êµí™˜  

---
### bubble ì •ë ¬ - ê¸°ë³¸ì •ë ¬ â”(BESTì—ì„œ íƒˆì¶œ)
:hash: BEST- O(N), AVG, WORST - O(N**2)  
ğŸ¥‡ì¼ë°˜ì ìœ¼ë¡œ swapì´ moveë³´ë‹¤ ë³µì¡í•˜ê¸° ë•Œë¬¸ì— ê±°ì˜ ì“°ì´ì§€ ì•ŠëŠ”ë‹¤.  
```{python}
def bubble_sort(A):
    # 
    for i in range(1,len(A)-1):

        for j in range(len(A)-i):
            # ë¹„êµ
            if A[j]>A[j+1]:
                A[j],A[j+1]=A[j+1],A[j]
        print(A)
    print(A)
```
---
### selection ì •ë ¬ - ê¸°ë³¸ ì •ë ¬  
:hash: BEST, AVG, WORST - O(N**2)
:star: ìµœì†Œë¥¼ ì„ íƒí•œë‹¤.
![image](https://user-images.githubusercontent.com/53412437/113525872-5aa02100-95f2-11eb-80d4-4c04eac3a21f.png)
```{python}
def selection_sort(array):
    for i in range(len(array)):
        m = i
        for j in range(i,len(array)):
            if array[j]<array[m]:
                m = j
        array[i],array[m] = array[m],array[i] # ìë¦¬ swap
    return array
```
---
### Insertion ì •ë ¬ - ê¸°ë³¸ ì •ë ¬
:hash: BEST, AVG - O(N**2) WORST - O(N)  
~ë°”ë¡œ ë°”ê¾¸ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ê°€ì¥ ì•ê¹Œì§€ ê°„ ë‹¤ìŒì— ë°”ê¾¼ë‹¤(Swapì˜ ë¹„ìš©ì´ ì ˆê°ë˜ê² êµ°)~
![image](https://user-images.githubusercontent.com/53412437/113782833-c65ac900-976d-11eb-9e06-46d4079cb995.png)
```{python}
def insertion_sort(A):
    for i in range(1,len(A)):
        for j in range(i,0,-1):
            if A[j-1]>A[j]: #ì• ë’¤
                A[j-1],A[j]=A[j],A[j-1]
            else:
                break
    return A
```
### heap

- `heapq`ë¥¼ í™œìš©í•˜ë©´ ë¨. heappush((ìš°ì„ ìˆœìœ„, ê°’)), heappop

- (ìµœëŒ€) í™ - ë¶€ëª¨ > ìì‹
- ì‹œê°„ ë³µì¡ë„ O(NlogN) - ë°ì´í„°ë¥¼ ë„£ì–´ì„œ heapifyí•  ë•Œ.
- ![](https://media.vlpt.us/images/nokia/post/f8835cee-b060-4857-b9c1-379d36a69662/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A2%20%E1%84%92%E1%85%B5%E1%86%B8.png)
  - listë¥¼ í™œìš© (index - 0, 1,2, ... ë¥¼ í™œìš©)
  - ì¢Œì¸¡ ìì‹ ë…¸ë“œ = 2 * ë¶€ëª¨ ë…¸ë“œ + 1 
  - ìš°ì¸¡ ìì‹ ë…¸ë“œ =  2 * ë¶€ëª¨ ë…¸ë“œ + 2
  - :heavy_check_mark: `starting idx = N//2` ì—¬ê¸°ì„œ `ê°ì†Œ`

```{python}
data = [5, 6, 3, 7, 9, 8, 1, 2, 4, 10]
class Heap(object):
    def __init__(self):
        self.array = []

    def push(self,data):
        # dataë¥¼ í•œê°œì”© ì‚½ì… O(N)
        self.array.append(data)
        # ì •ë ¬ O(logN)
		# â˜… ì™œ logNì¸ ì§€ë¥¼ ëª…í™•íˆ ì•Œê²Œ í•´ì£¼ë„¤
        # starting idxë¥¼ N//2ë¡œ í•´ì„œ ì‹œì‘
        idx = len(self.array)//2

        while idx>=0:
        # case 1 . ë¬´ìì‹
        	if (2*idx+1)>=len(self.array):
                pass
        # case 2 . ìì‹ 1ëª…
        	elif (2*idx+2)>=len(self.array):
                # í° ê°’ìœ¼ë¡œ swap
                if self.array[idx]<self.array[2*idx+1]:
                    self.array[idx],self.array[2*idx+1]=self.array[2*idx+1],self.array[idx]

        # case 3 .  ìì‹ 2ëª…
        	else:
                big_child=([2*idx+1,2*idx+2],key = lambda i : self.array[i])
                if self.array[idx]<self.array[big_child]:
					self.array[idx],self.array[big_child]=self.array[big_child],self.array[idx]
			idx+=1
	def pop(self):
        # ê°€ì¥ ë§ˆì§€ë§‰ì— ìˆëŠ” ê°’ì„ ìœ„ë¡œ ì˜¬ë¦¬ê³  N//2ì—ì„œ ë‹¤ì‹œ ìˆœì°¨ì ìœ¼ë¡œ ìì‹ê³¼ ë¹„êµ
        last = self.array.pop()
        first = self.array[0]
        self.array[0] = last
        idx = len(self.array)//2

        while idx>=0:
        # case 1 . ë¬´ìì‹
        	if (2*idx+1)>=len(self.array):
                pass
        # case 2 . ìì‹ 1ëª…
        	elif (2*idx+2)>=len(self.array):
                # í° ê°’ìœ¼ë¡œ swap
                if self.array[idx]<self.array[2*idx+1]:
                    self.array[idx],self.array[2*idx+1]=self.array[2*idx+1],self.array[idx]

        # case 3 .  ìì‹ 2ëª…
        	else:
                big_child=([2*idx+1,2*idx+2],key = lambda i : self.array[i])
                if self.array[idx]<self.array[big_child]:
					self.array[idx],self.array[big_child]=self.array[big_child],self.array[idx]
			idx+=1
            
            

        
```


### merge ì •ë ¬ - ê· í˜• ë¶„í•  (ì•ˆì •í•œ ì •ë ¬)  
![image](https://user-images.githubusercontent.com/53412437/113525448-f67c5d80-95ef-11eb-9ec8-51d993a3017c.png)  
:star: divided + conquer + merge
:hash: ì‹œê°„ ë³µì¡ë„ - BEST, AVG, WORST : NlogN  
- ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , í•©ì¹  ë•Œ sorting
```{python}
import sys
sys.setrecursionlimit(20000)
def divide(array):
    if len(array)<=1:
        return array
    else:
        l = len(array)//2
        return merge(divide(array[:l]),divide(array[l:]))
def merge(array1,array2):
    # ê°œìˆ˜ê°€ 1ê°œì§œë¦¬ë“¤ì¼ë•Œ
    new_array=[]
    i,j=0,0
    while i<len(array1) and j<len(array2):
        if array1[i]<array2[j]:
            new_array.append(array1[i])
            i+=1
        else:
            new_array.append(array2[j])
            j+=1
    if i<len(array1):
        new_array.extend(array1[i:])
    else:
        new_array.extend(array2[j:])
    return new_array
```


### quick ì •ë ¬ - ë¶ˆê· í˜• ë¶„í• 

:star: pivot + divided and conquer

:hash: ì‹œê°„ ë³µì¡ë„ - BEST : ~~O($ N$)~~  O(NlogN) // WORST :  O(N^2) - ì´ë¯¸ ì •ë ¬ëœ ê²½ìš° // AVG : O(NlogN)

- ë¹„êµ ì—°ì‚° : N / ê¹Šì´ : logN

```{python}
# WORST
[5,4,3,2,1]
[5],[4,3,2,1]
[4,3,2,1]//[5]
[4],[3,2,1]//[5]
[3,2,1]//[4]//[5]
[3],[2,1]//[4]//[5]
[2,1]//[3]//[4]//[5]
[2],[1]//[3]//[4]//[5]
[1]//[2]//[3]//[4]//[5]
```



```python
import sys
sys.setrecursionlimit(N)
def quick_sort(A):
    if len(A)<=1: # ë¹„ì–´ìˆì„ ë•Œë„ ìƒê°
        return A
    else:
        pivot = 0
        cnt = 1
        left = []
        right = []
        for i in A[1:]:
            if A[pivot]<i:
                right.append(i)
            elif A[pivot]>i:
                left.append(i)
            else:
                cnt+=1
        return quick_sort(left)+[A[pivot]]*cnt+quick_sort(right)
```




### count - `O(N)`

   - ì‘ì€ ë²”ìœ„ì˜ ì •ìˆ˜ ì •ë ¬ì— ìœ ìš©. 
   - ìˆ«ìì˜ ë°œìƒ íšŸìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” `ëˆ„ì  ì¹´ìš´íŠ¸` ì‚¬ìš©
   - ìˆ«ì ê°„ ê°„ê²©ì´ ì‘ì•„ì•¼ ì¢‹ìŒ

   ```{python}
   from collections import defaultdict
   def count_sort(a):
       # a - Nê°œì˜ ìˆ˜
       count = defaultdict(list)
       for i in a:
           count[i].append(i) # O(N)
       sorted_a = []
       for i in range(min(count),max(count)+1): # O(K)
           sorted_a.extend(count[i]) #O(N)
       # so O(N+K)
       return sorted_a
   ```
```
def count_sort(A):
    M = max(A) # O(N)
    
    c = [0]*(M+1)  # ë¹„ìŒì •ìˆ˜ë¥¼ ìƒê°í•˜ë©´
    for i in A:
        c[i]+=1
    
    # output array
    b = [-1]*len(A) 
    # ëˆ„ì í•©ì„ í•´ì¤€ë‹¤
    for i in range(M):
        c[i+1]+=c[i]
    print(c)
    # Më³´ë‹¤ len(A)ê°€ ë” ê¸¸ì´ê°€ ì§§ì„ í…Œë‹ˆ..
    #for i in range(M):
    #    b[i]=i
    # ì•„ë¦„ë‹µë‹¤..
    for i in range(len(A)-1,-1,-1):
        print(A[i])
        b[c[A[i]]-1]=A[i]
        c[A[i]]-=1
    print(b)
    #    b = a[j]
```
   
   
### Radix sort
https://www.zerocho.com/category/Algorithm/post/58007c338475ed00152d6c4c   
https://m.blog.naver.com/PostView.nhn?blogId=jhc9639&logNo=221258770067&proxyReferer=https:%2F%2Fwww.google.com%2F  ì°¸ì¡°  
LSD
:hash: ì‹œê°„ ë³µì¡ë„ O(dN) dëŠ” ìë¦¬ìˆ˜ , `ë¹„êµë¥¼ í•˜ì§€ ì•ŠëŠ”ë‹¤.`
ë‹¨ì  - ìë¦¬ìˆ˜ê°€ ì—†ëŠ” ê²ƒì€ ë¹„êµí•  ìˆ˜ ì—†ìŒ.  
```
A = [125, 383, 274, 96, 0, 9, 81, 72]

# round1 - 1ì˜ ìë¦¬ìˆ˜

[0],[72],[383],[274],[125],[96],[],[],[9]

# round 2 - 2ì˜ ìë¦¬ìˆ˜(1ì˜ ìë¦¬ìˆ˜ë¼ë©´ ì²«ì§¸ìë¦¬ìˆ˜ê°€ 0ì¸ ê²ƒìœ¼ë¡œ)
[0,9],[], [125], [], [], [], [], [72], [383], [96]

# round 3 - 3ì˜ ìë¦¬ìˆ˜ 
[0,9,72,96],[125], [], [383], [], [], [],[],[],[]

import math
#  ê° ìë¦¬ìˆ˜ë§ˆë‹¤ count sort ì‹¤ì‹œ
def get_digit(number,digit):
    return (number//(10**(digit-1)))%10

def count_sort_for_digit(A,digit):
    c = [0]*(10) # 0,1,2,..,10
    a = []
    for i in A:
        j=get_digit(i,digit)
        a.append(j)
        c[j]+=1
    
    for i in range(9):
        c[i+1]+=c[i]
    o = [-1]*len(A)
    for i in range(len(a)-1,-1,-1):
        
        
        
        o[c[a[i]]-1]=A[i]
        c[a[i]]-=1
    return o

def radix_sort(A):
    # ê°€ì¥ í° ìë¦¬ìˆ˜ í™•ì¸
    digit = 0
    for i in range(len(A)):
        if A[i]!=0:
            digit = max(int(math.log(A[i],10))+1,digit)
        else:
            digit = max(1,digit)
    print(digit)
    for i in range(1,digit+1):
        print(A)
        A=count_sort_for_digit(A,i)
    return A
```

### Topological sort - https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html ì°¸ì¡°
:hash: `Queue`
1. ì–´ë–¤ ì¼ì„ í•˜ëŠ” `ìˆœì„œ`ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ (`ë°©í–¥ ê·¸ë˜í”„`ì— ì¡´ì¬í•˜ëŠ” ê° ì •ì ë“¤ì˜ ì„ í–‰ ìˆœì„œë¥¼ ìœ„ë°°í•˜ì§€ ì•Šìœ¼ë©´ì„œ ëª¨ë“  ì •ì ì„ ë‚˜ì—´í•˜ëŠ” ê²ƒ)
:check: ê·¸ë˜í”„ì— ë‚¨ì•„ìˆëŠ” ì •ì  ì¤‘ì— `ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì `(fromì´ í•˜ë‚˜ë„ ì—†ëŠ” ì •ì )ì´ ì—†ë‹¤ë©´, ìœ„ìƒ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ì¤‘ë‹¨ë˜ê³ , ì´ëŸ¬í•œ ê·¸ë˜í”„ë¡œ í‘œí˜„ëœ ë¬¸ì œëŠ” ì‹¤í–‰ ë¶ˆê°€ëŠ¥í•œ ë¬¸ì œ.  
![image](https://user-images.githubusercontent.com/53412437/113575624-1e53db80-9659-11eb-9a39-148c49ab2293.png)  

#### step
1. ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ì •ì  ì„ íƒ
- ì§„ì… ì°¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš° ì–´ëŠ ì •ì ì„ ì„ íƒí•´ë„ ë¬´ë°©
- ì´ˆê¸°ì— ê°„ì„ ì˜ ìˆ˜ê°€ 0ì¸ ëª¨ë“  ì •ì ì„ íì— ì‚½ì…
2. ì„ íƒëœ ì •ì ê³¼ ì—¬ê¸°ì— ë¶€ì†ëœ ëª¨ë“  ê°„ì„ ì„ ì‚­ì œ
- ì„ íƒëœ ì •ì ì„ íì—ì„œ ì‚­ì œ(ìœ„ìƒ ìˆœì„œì— ì¶”ê°€)
- ì„ íƒëœ ì •ì ì— ë¶€ì†ëœ ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ ê°„ì„ ì˜ ìˆ˜ë¥¼ ê°ì†Œ
3. ìœ„ ê³¼ì •ì„ ë°˜ë³µí•´ì„œ ëª¨ë“  ì •ì ì´ ì„ íƒ, ì‚­ì œë˜ë©´ ì•Œê³ ë¦¬ì¦˜ ì¢…ë£Œ

#### ì˜ˆì‹œ
1. ê°ê°ì˜ ì‘ì—…ì´ ì™„ë£Œë˜ì–´ì•¼ ëë‚˜ëŠ” í”„ë¡œì íŠ¸
2. ì„ ìˆ˜ ê³¼ëª©
```{python}


from collections import deque
def topological_sort(graph,N):
queue = deque([])
# ì§„ì…ì°¨ìˆ˜ê°€ 0ì¸ Vertex ì°¾ê¸°
in_degree = [0] * N
order = []
idx = list(range(N))
for i in range(N):
for j in graph[i]:
	in_degree[j]+=1
for i in range(N):
if in_degree[i]==0:
    queue.append(i)
    in_degree[i]=-1
while queue:
next = queue.popleft()

order.append(next) # orderì— ì¶”ê°€
for j in graph[next]:
    in_degree[j]-=1
for i in range(N):
    if in_degree[i]==0:
	queue.append(i)
	in_degree[i]=-1
return order



```



     


   
   

   
