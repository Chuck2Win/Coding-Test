# 정렬 정리

- radix
- topological

  

---

1. bubble  
2. Insertion  
~3. selection~
### selection 정렬 - 기본 정렬  
:hash: BEST,AVG,WORST - O(N**2)

:star: 최소를 선택한다.
![image](https://user-images.githubusercontent.com/53412437/113525872-5aa02100-95f2-11eb-80d4-4c04eac3a21f.png)
```{python}
def selection_sort(array):
    for i in range(len(array)):
        m = i
        for j in range(i,len(array)):
            if array[j]<array[m]:
                m = j
        array[i],array[m] = array[m],array[i] # 자리 swap
    return array
```
~4. merge~  
~5. quick~  
### merge 정렬 - 균형 분할 (안정한 정렬)  
![image](https://user-images.githubusercontent.com/53412437/113525448-f67c5d80-95ef-11eb-9ec8-51d993a3017c.png)  
:star: divided + conquer + merge
:hash: 시간 복잡도 - BEST, AVG, WORST : NlogN  
- 반으로 나누고, 합칠 때 sorting
```{python}
import sys
sys.setrecursionlimit(20000)
def divide(array):
    if len(array)<=1:
        return array
    else:
        l = len(array)//2
        return merge(divide(array[:l]),divide(array[l:]))
def merge(array1,array2):
    # 개수가 1개짜리들일때
    new_array=[]
    i,j=0,0
    while i<len(array1) and j<len(array2):
        if array1[i]<array2[j]:
            new_array.append(array1[i])
            i+=1
        else:
            new_array.append(array2[j])
            j+=1
    if i<len(array1):
        new_array.extend(array1[i:])
    else:
        new_array.extend(array2[j:])
    return new_array
```


### quick 정렬 - 불균형 분할

:star: pivot + divided and conquer

:hash: 시간 복잡도 - BEST : ~~O($ N$)~~  O(NlogN) // WORST :  O(N^2) - 이미 정렬된 경우 // AVG : O(NlogN)

- 비교 연산 : N / 깊이 : logN

```{python}
# WORST
[5,4,3,2,1]
[5],[4,3,2,1]
[4,3,2,1]//[5]
[4],[3,2,1]//[5]
[3,2,1]//[4]//[5]
[3],[2,1]//[4]//[5]
[2,1]//[3]//[4]//[5]
[2],[1]//[3]//[4]//[5]
[1]//[2]//[3]//[4]//[5]
```



```python
import sys
sys.setrecursionlimit(N)
def quick_sort(A):
    if len(A)<=1: # 비어있을 때도 생각
        return A
    else:
        pivot = 0
        cnt = 1
        left = []
        right = []
        for i in A[1:]:
            if A[pivot]<i:
                right.append(i)
            elif A[pivot]>i:
                left.append(i)
            else:
                cnt+=1
        return quick_sort(left)+[A[pivot]]*cnt+quick_sort(right)
```



6. heap

- `heapq`를 활용하면 됨. heappush((우선순위, 값)), heappop

- (최대) 힙 - 부모 > 자식
- 시간 복잡도 O(NlogN) - 데이터를 넣어서 heapify할 때.
- ![](https://media.vlpt.us/images/nokia/post/f8835cee-b060-4857-b9c1-379d36a69662/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A2%20%E1%84%92%E1%85%B5%E1%86%B8.png)
  - list를 활용 (index - 0, 1,2, ... 를 활용)
  - 좌측 자식 노드 = 2 * 부모 노드 + 1 
  - 우측 자식 노드 =  2 * 부모 노드 + 2
  - :heavy_check_mark: `starting idx = N//2` 여기서 `감소`

```{python}
data = [5, 6, 3, 7, 9, 8, 1, 2, 4, 10]
class Heap(object):
    def __init__(self):
        self.array = []

    def push(self,data):
        # data를 한개씩 삽입 O(N)
        self.array.append(data)
        # 정렬 O(logN)
		# ★ 왜 logN인 지를 명확히 알게 해주네
        # starting idx를 N//2로 해서 시작
        idx = len(self.array)//2

        while idx>=0:
        # case 1 . 무자식
        	if (2*idx+1)>=len(self.array):
                pass
        # case 2 . 자식 1명
        	elif (2*idx+2)>=len(self.array):
                # 큰 값으로 swap
                if self.array[idx]<self.array[2*idx+1]:
                    self.array[idx],self.array[2*idx+1]=self.array[2*idx+1],self.array[idx]

        # case 3 .  자식 2명
        	else:
                big_child=([2*idx+1,2*idx+2],key = lambda i : self.array[i])
                if self.array[idx]<self.array[big_child]:
					self.array[idx],self.array[big_child]=self.array[big_child],self.array[idx]
			idx+=1
	def pop(self):
        # 가장 마지막에 있는 값을 위로 올리고 N//2에서 다시 순차적으로 자식과 비교
        last = self.array.pop()
        first = self.array[0]
        self.array[0] = last
        idx = len(self.array)//2

        while idx>=0:
        # case 1 . 무자식
        	if (2*idx+1)>=len(self.array):
                pass
        # case 2 . 자식 1명
        	elif (2*idx+2)>=len(self.array):
                # 큰 값으로 swap
                if self.array[idx]<self.array[2*idx+1]:
                    self.array[idx],self.array[2*idx+1]=self.array[2*idx+1],self.array[idx]

        # case 3 .  자식 2명
        	else:
                big_child=([2*idx+1,2*idx+2],key = lambda i : self.array[i])
                if self.array[idx]<self.array[big_child]:
					self.array[idx],self.array[big_child]=self.array[big_child],self.array[idx]
			idx+=1
            
            

        
```


~7.count~
### count - `O(N)`

   - 작은 범위의 정수 정렬에 유용. 
   - 숫자의 발생 횟수를 계산하는 `누적 카운트` 사용
   - 숫자 간 간격이 작아야 좋음

   ```{python}
   from collections import defaultdict
   def count_sort(a):
       # a - N개의 수
       count = defaultdict(list)
       for i in a:
           count[i].append(i) # O(N)
       sorted_a = []
       for i in range(min(count),max(count)+1): # O(K)
           sorted_a.extend(count[i]) #O(N)
       # so O(N+K)
       return sorted_a
   ```
   
   ### 위상정렬 - https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html 참조
   :hash: `Queue`
   1. 어떤 일을 하는 `순서`를 찾는 알고리즘 (`방향 그래프`에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것)
   :check: 그래프에 남아있는 정점 중에 `진입 차수가 0인 정점`(from이 하나도 없는 정점)이 없다면, 위상 정렬 알고리즘은 중단되고, 이러한 그래프로 표현된 문제는 실행 불가능한 문제.  
   ![image](https://user-images.githubusercontent.com/53412437/113575624-1e53db80-9659-11eb-9a39-148c49ab2293.png)  
   
   #### step
   1. 진입 차수가 0인 정점 선택
   - 진입 차수가 여러 개인 경우 어느 정점을 선택해도 무방
   - 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
   2. 선택된 정점과 여기에 부속된 모든 간선을 삭제
   - 선택된 정점을 큐에서 삭제(위상 순서에 추가)
   - 선택된 정점에 부속된 모든 간선에 대해 간선의 수를 감소
   3. 위 과정을 반복해서 모든 정점이 선택, 삭제되면 알고리즘 종료

   #### 예시
   1. 각각의 작업이 완료되어야 끝나는 프로젝트
   2. 선수 과목
   ```{python}
   graph = {0:[2,3], 1:[3,4], 2:[3,5], 3:[5], 4:[5], 5:[]}
N = 6
a=topological_sort(graph,N)
from collections import deque
def topological_sort(graph,N):
    queue = deque([])
    # 진입차수가 0인 Vertex 찾기
    s = set(sum(graph.values(),[]))
    order = []
    idx = list(range(N))
    for i in range(N):
        if i not in s:
            queue.append(i)
            idx.remove(i)
    #print(s)
    #print(queue)
    while queue:
        print(queue)
        next = queue.popleft()
        
        print(next)
        
        del graph[next] # 간선 삭제
        order.append(next) # order에 추가
        s = set(sum(graph.values(),[]))
        print(idx)
        print(s)
        for i in idx:
            if i not in s:
                queue.append(i)
                idx.remove(i)
    return order



   ```



     


   
   

   
