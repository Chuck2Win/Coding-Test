# Knapsack 문제

https://www.acmicpc.net/problem/12865

다이나믹 프로그래밍의 대표적인 문제

다이나믹 프로그래밍 - 조건 : 최적 부분 <!--전체의 최적이 부분의 최적을 항상 포함한다.--> & 중복 부분 구조

* 최적 부분 구조는 greedy algorithm의 조건이기도 하다.



Memoization을 활용함.

큰 문제를 작은 문제로 푼다는 것임.



## 문제

배낭에 넣을 수 있는 무게가 C일 때, 최대한 가치를 많이 담을 수 있는 값은?

ex) 

N = 4, C = 7

| #    | wi   | vi   |
| ---- | ---- | ---- |
| 1    | 2    | 3    |
| 2    | 3    | 4    |
| 3    | 4    | 5    |
| 4    | 5    | 6    |



최적 부분 조건 파악하기

item n까지를 담은 해라고 한다면,

- <u>item n을 포함하는 경우</u>(item n-1까지의 해 + item n의 가치)
  - P[n,w] = max(P[n-1,w], *P[n-1,w-wi]+vi*)
- <u>item n을 포함하지 않는 경우</u>(item(n-1)가지의 해)
  - P[n,w] = max(*P[n-1,w]*, P[n-1,w-wi]+vi)

| #    | W    | V    |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 1    | 6    | 13   |
| 2    | 4    | 8    |
| 3    | 3    | 6    |
| 4    | 5    | 12   |

```python
table = [[0 for _ in range(C+1)] for _ in range(N+1)] # item : 행 // capa : 열
for i in range(1,N+1):
	if w[i]>w:
    	P[i][j]=P[i-1][j]
    else:
        P[i][j]=max([P[i-1][j],P[i-1][j-w[i]]+v[i]])
```



|      | 0     | 1    | 2    | 3            | 4                 | 5     | 6                | 7                 |      |
| ---- | ----- | ---- | ---- | ------------ | ----------------- | ----- | ---------------- | ----------------- | ---- |
| 0    | **0** | *0*  | 0    | 0            | 0                 | 0     | 0                | 0                 |      |
| 1    | **0** | *0*  | 0*   | 0**          | 0                 | 0     | **0**+13         | *0*+13            |      |
| 2    | **0** | *0*  | 0*   | 0**          | **0**+8           | *0*+8 | max(0*+8,P[1,6]) | max(0**+8,P[1,7]) |      |
| 3    | 0     | 0    | 0    | max(**0**+6) | max(*0*+6,P[2,4]) |       |                  |                   |      |
| 4    | 0     |      |      |              |                   |       |                  |                   |      |
|      |       |      |      |              |                   |       |                  |                   |      |



# 기타리스트

https://www.acmicpc.net/problem/1495

존재여부만을 check

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |
| 2    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 0    |
| 3    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    |

N=3, S=5,M=10

[3,5,7]

```python
N,S,M = map(int,input().split())
V = list(map(int,input().split()))
table = [[0 for _ in range(M+1)] for _ in range(N+1)]
table[0][S]=1
for i in range(0,N):
	for j in range(0,M):
	    if table[i][j]:
            if 0<=j-V[i+1]<=M:
                table[i+1][j-V[i+1]]=1
            if 0<=j+V[i+1]<=M::
                table[i+1][j+V[i+1]]=1
```



